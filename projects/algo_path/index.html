<!doctype html><html lang='en'><head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<title>Algo Studio: Pathfinding & Mazes</title><link rel='stylesheet' href='../../assets/css/style.css'></head><body>
<header class='nav'><div class='container'><a class='brand' href='../../index.html'>&larr; Back</a><button id='theme' class='btn'>Theme</button></div></header>
<section class='container prose'>
  <h2>Algo Studio: Pathfinding & Mazes</h2>
  <p><strong>What you see:</strong> a grid with a start (green) and goal (red). Walls are blocks. The path animates with an expanding blue trail and live counters.</p>
  <p><strong>How to use:</strong> click/drag to draw walls; drag start/goal; generate a maze; choose A* or Dijkstra; press Run; adjust speed.</p>
  
<div class="controls">
  <button class="btn" id="maze">Maze</button>
  <select id="algo"><option value="astar">A*</option><option value="dijkstra">Dijkstra</option></select>
  <label>Speed <input id="spd" type="range" min="1" max="10" value="6"></label>
  <button class="btn" id="run">Run</button>
  <button class="btn" id="clear">Clear</button>
  <span class="kpi">Explored: <span id="kExp">0</span></span>
  <span class="kpi">Path: <span id="kLen">0</span></span>
</div>
<canvas id="grid" width="900" height="540" class="stage"></canvas>

</section>
<footer><div class='container'>Contact: <a href='mailto:ambrosetheshield6@gmail.com'>ambrosetheshield6@gmail.com</a></div></footer>
<script>document.getElementById('theme').onclick=()=>document.documentElement.classList.toggle('light');</script>

<script>
const W=45,H=27,S=20, cv=document.getElementById('grid'), ctx=cv.getContext('2d');
let start={x:2,y:2}, goal={x:W-3,y:H-3}, walls=new Set(); let speed=6;
function key(x,y){return x+','+y}
function draw(bg=true){
  if(bg){ctx.fillStyle='#0c142b'; ctx.fillRect(0,0,cv.width,cv.height);}
  ctx.strokeStyle='#1a2b55';
  for(let x=0;x<=W;x++){ctx.beginPath();ctx.moveTo(x*S,0);ctx.lineTo(x*S,H*S);ctx.stroke()}
  for(let y=0;y<=H;y++){ctx.beginPath();ctx.moveTo(0,y*S);ctx.lineTo(W*S,y*S);ctx.stroke()}
  ctx.fillStyle='#122957'; walls.forEach(k=>{const [x,y]=k.split(',').map(Number); ctx.fillRect(x*S+1,y*S+1,S-2,S-2)});
  ctx.fillStyle='#37f26e'; ctx.fillRect(start.x*S+3,start.y*S+3,S-6,S-6);
  ctx.fillStyle='#ff6b6b'; ctx.fillRect(goal.x*S+3,goal.y*S+3,S-6,S-6);
}
function toggle(x,y){const k=key(x,y); if(walls.has(k)) walls.delete(k); else walls.add(k);}
let painting=false, dragging=null;
cv.addEventListener('mousedown',e=>{const r=cv.getBoundingClientRect(); const x=Math.floor((e.clientX-r.left)/S), y=Math.floor((e.clientY-r.top)/S);
  if(x===start.x&&y===start.y) dragging='start'; else if(x===goal.x&&y===goal.y) dragging='goal'; else {painting=true; toggle(x,y);} draw(false)});
cv.addEventListener('mousemove',e=>{const r=cv.getBoundingClientRect(); const x=Math.floor((e.clientX-r.left)/S), y=Math.floor((e.clientY-r.top)/S);
  if(dragging==='start'){start={x,y}; draw(false)} else if(dragging==='goal'){goal={x,y}; draw(false)} else if(painting){toggle(x,y); draw(false)}});
window.addEventListener('mouseup',()=>{painting=false; dragging=null});

function neighbors(n){const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; const res=[]; for(const [dx,dy] of dirs){const x=n.x+dx,y=n.y+dy; if(x>=0&&x<W&&y>=0&&y<H&&!walls.has(key(x,y))) res.push({x,y})} return res}
function heur(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)}
function runASTAR(){return runGeneric(true)}
function runDijkstra(){return runGeneric(false)}
function runGeneric(useHeur){const open=[start]; const g=new Map([[key(start.x,start.y),0]]); const came=new Map(); const f=new Map([[key(start.x,start.y),useHeur?heur(start,goal):0]]); const seen=new Set([key(start.x,start.y)]); let explored=0;
  while(open.length){open.sort((u,v)=>(f.get(key(u.x,u.y))||1e9)-(f.get(key(v.x,v.y))||1e9)); const cur=open.shift(); explored++;
    if(cur.x===goal.x&&cur.y===goal.y){document.getElementById('kExp').textContent=explored; return {came,cur};}
    for(const nb of neighbors(cur)){const nk=key(nb.x,nb.y), ck=key(cur.x,cur.y); const tent=(g.get(ck)||0)+1;
      if(!g.has(nk)||tent<g.get(nk)){came.set(nk,ck); g.set(nk,tent); let pr=tent+(useHeur?heur(nb,goal):0); f.set(nk,pr); if(!seen.has(nk)){open.push(nb); seen.add(nk)}}}
  } return null}
function reconstruct(came,cur){const path=[cur]; let k=key(cur.x,cur.y); while(came.has(k)){k=came.get(k); const [x,y]=k.split(',').map(Number); path.push({x,y});} return path.reverse()}
function animate(path){document.getElementById('kLen').textContent=path.length;
  let i=0; const id=setInterval(()=>{ if(i>=path.length){clearInterval(id); return;} const p=path[i++]; ctx.fillStyle='#6aa8ff'; ctx.fillRect(p.x*S+4,p.y*S+4,S-8,S-8);}, Math.max(4, 22-(+document.getElementById('spd').value*2)))}
document.getElementById('run').onclick=()=>{draw(); const useA = document.getElementById('algo').value==='astar'; const res = useA?runASTAR():runDijkstra(); if(!res){return} const path=reconstruct(res.came,res.cur); animate(path)}
document.getElementById('clear').onclick=()=>{walls.clear(); draw()};
document.getElementById('spd').oninput=e=>speed=+e.target.value;
document.getElementById('maze').onclick=()=>{walls.clear(); // Recursive division-ish
  function carve(x0,y0,x1,y1){ if(x1-x0<4||y1-y0<4) return; if((x1-x0)>(y1-y0)){ const x=Math.floor((x0+x1)/2); for(let y=y0;y<y1;y++) if(!(y%5)) walls.add(key(x,y));
    const gap=y0+2+Math.floor(Math.random()*(y1-y0-4)); for(let dy=-1;dy<=1;dy++) walls.delete(key(x,gap+dy)); carve(x0,y0,x,y1); carve(x+1,y0,x1,y1);
  } else { const y=Math.floor((y0+y1)/2); for(let x=x0;x<x1;x++) if(!(x%5)) walls.add(key(x,y));
    const gap=x0+2+Math.floor(Math.random()*(x1-x0-4)); for(let dx=-1;dx<=1;dx++) walls.delete(key(gap+dx,y)); carve(x0,y0,x1,y); carve(x0,y+1,x1,y1);} }
  carve(1,1,W-2,H-2); draw() };
draw();
</script>

</body></html>